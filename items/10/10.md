# 클래스

### 클래스 체계

- 클래스를 정의하는 표준 자바 관례에 따르면,
  - 가장 먼저 변수 목록이 나온다
    - 정적(`static`), 공개(`public`) 상수가 있다면 맨 처음 나온다
    - 그 다음 정적 비공개(`private`) 변수가 나오며
    - 이어서, 비공개 인스턴스 변수가 나온다
      - 공개 변수가 필요한 경우는 거의 없다
  - 변수 목록 다음에는 공개 함수가 나온다
    - 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다
      - 즉, 추상화 단계가 순차적으로 내려간다

> 그래서 프로그램은 신문 기사처럼 읽힌다

#### ■ 캡슐화

- 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다
- 때로는 변수나 유틸리티 함수를 `protected`로 선언해 테스트 코드에 접근을 허용하기도 한다
  - 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 `protected`로 선언하거나 패키지 전체로 공개한다
  - 하지만 그 전에 비공개 상태를 유지할 온갖 방법을 강구한다
- 캡술화를 풀어주는 결정은 언제나 최후의 수단이다

<br />

### 클래스는 작아야 한다

- 클래스를 만들 때 첫 번쨰 규칙은 크기다. 클래스는 작아야 한다
  - 두 번쨰 규칙도 크기다. 더 작아야 한다
  - 클래스를 설계할 때도, 함수와 마찬가지로 `작게`가 기본 규칙이다
    - 함수는 물리적인 행 수로 크기를 측정했지만
    - 클래스는 맡은 책임을 척도로 크기를 측정한다
- 클래스 이름은 해당 클래스의 책임을 기술해야 한다
  - 실제로 작명은 클래스 크기를 줄이는 첫 번째 관문이다
  - 간결한 이름이 떠오르지 않는다면 필경 클래스의 크기가 너무 커서 그렇다. 책임이 너무 많아서 그렇다는 의미다

#### ■ 단일 책임 원칙(`Single Reponsebility Principle`, `SRP`)

- 클래스나 모듈은 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다
- `SRP`는 `책임`이라는 개념을 정의하며 적절한 크기를 제시한다

> 클래스는 `책임`, 즉 `변경할 이유`가 하나여야 한다는 의미

- `SRP`는 객체 지향 설계에서 더욱 중요한 개념이다
  - 또한 이해하고 지키기 수월한 개념이기도 하다
- 소프틍웨어를 돌아가게 만드는 활동과 깨끗하게 만드는 활동은 별개다
  - 대다수는 두뇌 용량에 한계가 있어 `돌아가는 소프트웨어`에 초점을 맞춘다
    - 전적으로 올바른 태도다
  - 관심사를 분리하는 작업은 프로그램만이 아니라 프로그래밍 활동에서도 마찬가지로 중요하다
- 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다
  - 작은 클래스는 각자 맡은 책임이 하나며
  - 변경할 이유가 하나며
  - 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다

<br />

### 응집도(`Cohesion`)

> 응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미다

- 클래스는 인스턴스 변수 수가 작아야 한다
  - 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다
    - 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다.
    - 일반적으로 응집도가 가장 높은 클래스는 가능하지도 바람직하지도 않다
- "함수를 작게, 매개변수 목록을 짧게"라는 전략을 따르다 보면 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다
  - 이는 십중팔구 새로운 클래스로 쪼개야 한다는 신호다
- 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다

#### ■ 응집도를 유지하면 작은 클래스 여럿이 나온다

- 클래스가 응집력을 잃는다면 쪼개라
- 큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다
- 그러면서 프로그램에 점점 더 체계가 잡히고 구조가 투명해진다

<br />

### 변경하기 쉬운 클래스

- 대다수 시스템은 지속적인 변경이 가해진다
- 그리고 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 따른다
- 깨끗한 시스템응ㄴ 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다
- 클래스가 분리되면
  - 클래스 자체가 극도로 단순해진다
  - 코드를 순식간에 이해할 수 있다
  - 함수 하나를 수정했다고 다른 함수가 망가질 위험도 사라진다
  - 테스트 관점에서 모든 논리를 구석구석 증명하기도 쉬워진다
- 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다
- 이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다

#### ■ 변경으로부터 격리

- 요구사항은 변하기 마련이다
  - 따라서 코드도 변하기 마련이다
- 구체적인(`concrete`) 클래스는 상세한 구현(코드)를 포함하며 추상(`abstract`)적인 클래스는 개념만 포함한다
- 상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다
- 그래서 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다
  - 상세한 구현에 의존하는 코드는 테스트하기 어렵다
  - 테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 재사용성도 높아진다
  - 결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미다
    - 시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이해하기도 더 쉬워진다
    - 이렇게 결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인 `DIP`(`Dependency Inversion Principle`)을 따르는 클래스가 나온다
      - `DIP`는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다

<br /><br />
